# ==========================================================
# afl/Makefile.fuzz — AFL++ + Verilator Fuzzing Framework
# ==========================================================

# Project & Locations
TOP_DIR     := $(abspath ..)
FUZZ_DIR    := $(abspath .)

MODULE      ?= picorv32
OBJ_DIR     := $(TOP_DIR)/verilator/obj_dir
HARNESS_SRC := $(TOP_DIR)/harness/tb_$(MODULE)_fuzz.cpp
RTL_FILE    := $(TOP_DIR)/rtl/cpu/$(MODULE)/$(MODULE).v

BIN_DIR     := $(TOP_DIR)/firmware/build

INPUT_DIR   ?= $(FUZZ_DIR)/seeds
OUTPUT_DIR  ?= $(FUZZ_DIR)/corpora
TRACE_DIR   ?= $(FUZZ_DIR)/traces
CORES       ?= 1
TIMEOUT     ?= none
MEM_LIMIT   ?= none
MAX_CYCLES  ?= 10000

FUZZ_EXE    := $(FUZZ_DIR)/afl_$(MODULE)

# Mutator (auto-build)
MUT_DIR     := $(FUZZ_DIR)/rv32_mutator
MUT_SO      := $(MUT_DIR)/librv32_mutator.so

# Optional AFL config
FUZZ_CONF   := $(FUZZ_DIR)/afl.conf
ifneq ("$(wildcard $(FUZZ_CONF))","")
include $(FUZZ_CONF)
endif

# Colors
YELLOW := \033[1;33m
GREEN  := \033[1;32m
BLUE   := \033[1;34m
RESET  := \033[0m

# Phony
.PHONY: all check dirs verilate build fuzz crash-traces triage clean

# Default
all: fuzz

# Sanity check
check:
	@which verilator >/dev/null || (echo "$(YELLOW)[ERROR] Verilator not found$(RESET)"; exit 1)
	@which afl-clang-fast++ >/dev/null || (echo "$(YELLOW)[ERROR] AFL++ not found$(RESET)"; exit 1)
	@echo "$(GREEN)[OK] Toolchain verified: Verilator + AFL++$(RESET)"

# Prepare dirs + auto seeds from firmware
dirs:
	@mkdir -p $(INPUT_DIR) $(OUTPUT_DIR) $(TRACE_DIR)
	@if ls -1 $(BIN_DIR)/*.bin >/dev/null 2>&1; then \
		echo "$(BLUE)[SEEDS] Found .bin files in $(BIN_DIR); copying to $(INPUT_DIR)$(RESET)"; \
		cp -n $(BIN_DIR)/*.bin $(INPUT_DIR)/; \
	else \
		echo "$(YELLOW)[SEEDS] No .bin files in $(BIN_DIR); leaving $(INPUT_DIR) unchanged$(RESET)"; \
	fi
	@echo "$(GREEN)[OK] Directories ready (seeds, corpora, traces)$(RESET)"

# Verilate
verilate:
	@echo "$(BLUE)[VERILATE] Translating $(MODULE) for fuzzing...$(RESET)"
	verilator -Wall --x-assign unique --x-initial unique --trace \
		-Wno-fatal -Wno-DECLFILENAME -Wno-UNUSEDSIGNAL -Wno-BLKSEQ -Wno-GENUNNAMED \
		-DRISCV_FORMAL \
		--cc $(RTL_FILE) \
		--exe $(HARNESS_SRC) \
		--top-module $(MODULE) \
		--Mdir $(OBJ_DIR)
	@echo "$(GREEN)[OK] Verilated model generated.$(RESET)"

# Build harness with AFL++ (auto-build mutator)
build: check dirs verilate $(MUT_SO)
	@echo "$(BLUE)[BUILD] Compiling harness using AFL++...$(RESET)"
	$(MAKE) -C $(OBJ_DIR) -f V$(MODULE).mk V$(MODULE)__ALL.a

	afl-clang-fast++ -std=c++17 -O2 \
		-I$(OBJ_DIR) \
		-I/usr/share/verilator/include \
		-I/usr/share/verilator/include/vltstd \
		$(HARNESS_SRC) \
		$(OBJ_DIR)/V$(MODULE)__ALL.a \
		/usr/share/verilator/include/verilated.cpp \
		/usr/share/verilator/include/verilated_vcd_c.cpp \
		/usr/share/verilator/include/verilated_threads.cpp \
		-o $(FUZZ_EXE) \
		-lpthread -latomic

	@echo "$(GREEN)[OK] Built fuzz executable: $(FUZZ_EXE)$(RESET)"

# Build the mutator shared library (auto)
$(MUT_SO):
	@echo "$(BLUE)[MUTATOR] Building RV32 hybrid mutator...$(RESET)"
	$(MAKE) -C $(MUT_DIR)
	@echo "$(GREEN)[OK] Built $(MUT_SO)$(RESET)"

# Run AFL++
fuzz: build
	@echo "$(BLUE)[RUN] Starting AFL++ fuzzing with custom mutator...$(RESET)"
	@echo "$(BLUE)      Using mutator: $(MUT_SO)$(RESET)"
	@if [ "$(CORES)" = "1" ]; then \
		AFL_CUSTOM_MUTATOR_LIBRARY=$(MUT_SO) \
		afl-fuzz -i $(INPUT_DIR) -o $(OUTPUT_DIR) -m $(MEM_LIMIT) -t $(TIMEOUT) -- $(FUZZ_EXE) @@; \
	else \
		echo "[MASTER] Starting master..."; \
		AFL_CUSTOM_MUTATOR_LIBRARY=$(MUT_SO) \
		afl-fuzz -i $(INPUT_DIR) -o $(OUTPUT_DIR) -M main -- $(FUZZ_EXE) @@ & \
		sleep 2; \
		for i in $$(seq 1 $$(($(CORES)-1))); do \
			echo "[SLAVE $$i] Starting worker..."; \
			AFL_CUSTOM_MUTATOR_LIBRARY=$(MUT_SO) \
			afl-fuzz -i $(INPUT_DIR) -o $(OUTPUT_DIR) -S slave$$i -- $(FUZZ_EXE) @@ & \
			sleep 2; \
		done; \
		wait; \
	fi

# Replay crashes and dump VCD
crash-traces:
	@echo "$(BLUE)[REPLAY] Dumping VCD traces for crashes...$(RESET)"
	@mkdir -p $(TRACE_DIR)
	@for f in $(OUTPUT_DIR)/crashes/id_*; do \
		[ -f $$f ] || continue; \
		echo "→ Replaying $$f"; \
		AFL_DUMP_VCD=$(TRACE_DIR)/$$(basename $$f).vcd $(FUZZ_EXE) $$f > /dev/null 2>&1 || true; \
	done
	@echo "$(GREEN)[OK] Waveforms stored in $(TRACE_DIR)/$(RESET)"

# Triage (minimize crash inputs)
triage:
	@echo "$(BLUE)[TRIAGE] Minimizing crashes with afl-tmin...$(RESET)"
	@mkdir -p $(OUTPUT_DIR)/triaged
	@for f in $(OUTPUT_DIR)/crashes/id_*; do \
		[ -f $$f ] || continue; \
		echo "→ Minimizing $$f"; \
		afl-tmin -i $$f -o $(OUTPUT_DIR)/triaged/$$(basename $$f) -- $(FUZZ_EXE) @@; \
	done
	@echo "$(GREEN)[OK] Triaged crashes saved to $(OUTPUT_DIR)/triaged$(RESET)"

# Clean
clean:
	@echo "$(YELLOW)[CLEAN] Removing fuzz artifacts...$(RESET)"
	rm -rf $(OUTPUT_DIR) $(INPUT_DIR) $(TRACE_DIR) $(FUZZ_EXE)
	@$(MAKE) -C $(MUT_DIR) clean || true
	@echo "$(GREEN)[OK] Cleanup complete.$(RESET)"
