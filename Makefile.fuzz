# ==========================================================
#  Makefile.fuzz — AFL++ + Verilator Fuzzing Framework
# ==========================================================

MODULE       := picorv32
TOP_DIR      := $(PWD)
OBJ_DIR      := $(TOP_DIR)/verilator/obj_dir
HARNESS_SRC  := $(TOP_DIR)/harness/tb_$(MODULE)_fuzz.cpp
RTL_FILE     := $(TOP_DIR)/rtl/cpu/$(MODULE)/$(MODULE).v
BIN_DIR      := $(TOP_DIR)/firmware/build

FUZZ_DIR     := $(TOP_DIR)/afl
FUZZ_CONF    := $(FUZZ_DIR)/afl.conf
FUZZ_EXE     := $(FUZZ_DIR)/afl_$(MODULE)

INPUT_DIR    := seeds
OUTPUT_DIR   := corpora
TRACE_DIR    := traces/fuzz
CORES        := 1
TIMEOUT      := none
MEM_LIMIT    := none
MAX_CYCLES   := 10000

# --------------------------------------
# Load optional AFL config if it exists
# --------------------------------------
ifneq ("$(wildcard $(FUZZ_CONF))","")
include $(FUZZ_CONF)
endif

# --------------------------------------
# Colors
# --------------------------------------
YELLOW := \033[1;33m
GREEN  := \033[1;32m
BLUE   := \033[1;34m
RESET  := \033[0m

# --------------------------------------
# Phony targets
# --------------------------------------
.PHONY: all dirs verilate build fuzz crash-traces triage clean check

# --------------------------------------
# Sanity check
# --------------------------------------
check:
	@which verilator >/dev/null || (echo "$(YELLOW)[ERROR] Verilator not found$(RESET)"; exit 1)
	@which afl-clang-fast++ >/dev/null || (echo "$(YELLOW)[ERROR] AFL++ not found$(RESET)"; exit 1)
	@echo "$(GREEN)[OK] Toolchain verified: Verilator + AFL++$(RESET)"

# --------------------------------------
# Default target
# --------------------------------------
all: fuzz

# --------------------------------------
# Prepare directories and seed
# --------------------------------------
dirs:
	@mkdir -p $(INPUT_DIR) $(OUTPUT_DIR) $(TRACE_DIR)
	@# If one or more .bin files are present in firmware/build, copy them to seeds; otherwise skip
	@if ls -1 $(BIN_DIR)/*.bin >/dev/null 2>&1; then \
		echo "$(BLUE)[SEEDS] Found .bin files in $(BIN_DIR); copying to $(INPUT_DIR)$(RESET)"; \
		cp -n $(BIN_DIR)/*.bin $(INPUT_DIR)/; \
	else \
		echo "$(YELLOW)[SEEDS] No .bin files in $(BIN_DIR); leaving $(INPUT_DIR) unchanged$(RESET)"; \
	fi
	@echo "$(GREEN)[OK] Directories ready (seeds, corpora, traces)$(RESET)"

# --------------------------------------
# Verilate
# --------------------------------------
verilate:
	@echo "$(BLUE)[VERILATE] Translating $(MODULE) for fuzzing...$(RESET)"
	verilator -Wall --x-assign unique --x-initial unique --trace \
		-Wno-fatal -Wno-DECLFILENAME -Wno-UNUSEDSIGNAL -Wno-BLKSEQ -Wno-GENUNNAMED \
		-DRISCV_FORMAL \
		--cc $(RTL_FILE) \
		--exe $(HARNESS_SRC) \
		--top-module $(MODULE) \
		--Mdir $(OBJ_DIR)
	@echo "$(GREEN)[OK] Verilated model generated.$(RESET)"

# --------------------------------------
# Build harness with AFL++
# --------------------------------------
build: check verilate
	@echo "$(BLUE)[BUILD] Compiling harness using AFL++...$(RESET)"
	$(MAKE) -C $(OBJ_DIR) -f V$(MODULE).mk V$(MODULE)__ALL.a

	afl-clang-fast++ -std=c++17 -O2 \
		-I$(OBJ_DIR) \
		-I/usr/share/verilator/include \
		-I/usr/share/verilator/include/vltstd \
		$(HARNESS_SRC) \
		$(OBJ_DIR)/V$(MODULE)__ALL.a \
		/usr/share/verilator/include/verilated.cpp \
		/usr/share/verilator/include/verilated_vcd_c.cpp \
		/usr/share/verilator/include/verilated_threads.cpp \
		-o $(FUZZ_EXE) \
		-lpthread -latomic

	@echo "$(GREEN)[OK] Built fuzz executable: $(FUZZ_EXE)$(RESET)"

# --------------------------------------
# Run AFL++
# --------------------------------------
fuzz: dirs build
	@echo "$(BLUE)[RUN] Starting AFL++ fuzzing...$(RESET)"
	@if [ "$(CORES)" = "1" ]; then \
		afl-fuzz -i $(INPUT_DIR) -o $(OUTPUT_DIR) -m $(MEM_LIMIT) -t $(TIMEOUT) -- $(FUZZ_EXE) @@; \
	else \
		echo "[MASTER] Starting master..."; \
		afl-fuzz -i $(INPUT_DIR) -o $(OUTPUT_DIR) -M main -- $(FUZZ_EXE) @@ & \
		sleep 2; \
		for i in $$(seq 1 $$(($(CORES)-1))); do \
			echo "[SLAVE $$i] Starting worker..."; \
			afl-fuzz -i $(INPUT_DIR) -o $(OUTPUT_DIR) -S slave$$i -- $(FUZZ_EXE) @@ & \
			sleep 2; \
		done; \
		wait; \
	fi

# --------------------------------------
# Replay crashes and dump VCD
# --------------------------------------
crash-traces:
	@echo "$(BLUE)[REPLAY] Dumping VCD traces for crashes...$(RESET)"
	@mkdir -p $(TRACE_DIR)
	@for f in $(OUTPUT_DIR)/crashes/id_*; do \
		[ -f $$f ] || continue; \
		echo "→ Replaying $$f"; \
		AFL_DUMP_VCD=$(TRACE_DIR)/$$(basename $$f).vcd $(FUZZ_EXE) $$f > /dev/null 2>&1 || true; \
	done
	@echo "$(GREEN)[OK] Waveforms stored in $(TRACE_DIR)/$(RESET)"

# --------------------------------------
# Triage (minimize crash inputs)
# --------------------------------------
triage:
	@echo "$(BLUE)[TRIAGE] Minimizing crashes with afl-tmin...$(RESET)"
	@mkdir -p $(OUTPUT_DIR)/triaged
	@for f in $(OUTPUT_DIR)/crashes/id_*; do \
		[ -f $$f ] || continue; \
		echo "→ Minimizing $$f"; \
		afl-tmin -i $$f -o $(OUTPUT_DIR)/triaged/$$(basename $$f) -- $(FUZZ_EXE) @@; \
	done
	@echo "$(GREEN)[OK] Triaged crashes saved to $(OUTPUT_DIR)/triaged$(RESET)"

# --------------------------------------
# Clean
# --------------------------------------
clean:
	@echo "$(YELLOW)[CLEAN] Removing fuzz artifacts...$(RESET)"
	rm -rf $(OUTPUT_DIR) $(INPUT_DIR) $(TRACE_DIR) $(FUZZ_EXE)
	@echo "$(GREEN)[OK] Cleanup complete.$(RESET)"
